
/*
 * Cette classe est l'unique travail de Mehdi Bakhtar et de Théo Foutel-Rodier.
 * Elle n'est présente ici que dans le seul but de comparer les implémentations au travers de tests de performances.
 * 
 * This class is solely the work of Mehdi Bakhtar and Théo Foutel-Rodier.
 * It is present here only as the purpose of comparating implementations for performance tests.
 */

package qengine.concurrent.storage;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.NotImplementedException;

import fr.boreal.model.logicalElements.api.Term;


/*
 * Encodes and decodes Term objects into numeric integer tokens for faster querying
 * Can be persisted and loaded from file (not yet implemented)
 */
public class ConcurrentEncodingDictionary {

	private Map<Term, Integer> encodingMap;
    //integers >= 0
    /*
    Note:
    Here, we used the HashMap implementation of the Map interface, but you have to be careful when doing so because it presupposes that the objects you are going to hash have proper hashCode() and equals() implementations for the HashMap to work as intended.
    Since the Term interface objects we are going to use/instantiate (in our tests and the source code) are provided/generated by Boreal's SameObjectTermFactory which handles all of that by guaranteeing that Term objects created with the same parameters and same class/type (Variable, Literal, Constant, ...) do correspond to the same Java object reference.
    That way, we can be sure that those methods will be properly defined for the objects we are going to use and the HashMap will work as intended.
    From the documentation (https://rules.gitlabpages.inria.fr/integraal/fr.boreal.model/fr/boreal/model/logicalElements/factory/impl/SameObjectTermFactory.html):
    "This factory creates Terms for each call at the same method with the same parameters, the same java object will be returned. Therefore, the equality test between those objects can be restricted to java object reference comparison (==).
    Please make sure the term implementations used are immutable otherwise there could be unwanted side effects."
    */
    
	private List<Term> decodingList;

	private int nextIndex;
	
	public ConcurrentEncodingDictionary() {
		nextIndex = 0;
		//by using a HashMap, we suppose/hope that the Term objects are not hashed based on their memory address but on their content
		encodingMap = new HashMap<>();
		decodingList = new ArrayList<>();
	}
	
	public ConcurrentEncodingDictionary(File dictFile) {
		// load the dictionary from previous data
		throw new NotImplementedException();
	}
	
	/*
	 * Returns the Id encoding for the input
	 * If input not present in dictionary gives it a new id
	 * Giving a new id updates both dictionary 
	 */
	public Integer encode(Term input) {
		Integer id = encodingMap.getOrDefault(input, this.nextIndex);
		
		// update reverse dict and next_index if a new id was issued
		if (id == this.nextIndex) {
            this.encodingMap.put(input, id);
			this.decodingList.add(input);
			this.nextIndex++;
		}
		
		return id;
	}
	
	/*
	 * Returns String value of token
	 * Throws RunTimeException if passed a token not present in dictionary
	 */
	public Term decode(Integer encodedTermValue) {
		Term decodedTerm = decodingList.get(encodedTermValue);
		if (decodedTerm == null) {
			throw new RuntimeException("Unknown id was passed to EncodingDictionary decode function: " + String.valueOf(encodedTermValue));
		} else {
			return decodedTerm;
		}
		
	}
	
	/*
	 * Returns the current size of the dictionary
	 */
	public int getSize() {
		return this.nextIndex;
	}

    /*
     * Checks whether a specific Term is in the dictionary
     */
    public boolean hasTerm(Term t) { return encodingMap.containsKey(t); }

    /*
     * Checks whether a specific id is in the dictionary
     */
    public boolean hasId(Integer id) {
        return (id < nextIndex) && (id >= 0);
    }
	
}